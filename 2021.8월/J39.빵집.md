# 빵집
https://www.acmicpc.net/problem/3109

첫 풀이 : 완전탐색 기법을 사용했다.
답은 정확하게 나지만, 시간이 오래 걸린다.
```java

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class A0819_빵집 {
	static int R,C;
	static char[][] field;
	static char[][] testfield;
	static int answer;
	
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		R = Integer.parseInt(st.nextToken());
		C = Integer.parseInt(st.nextToken());
		
		field = new char[R][C];
		for (int i = 0; i < R; i++) {
			String arr = br.readLine();
			for (int j = 0; j < C; j++) {
				field[i][j] = arr.charAt(j);
			}
		}
		
		// 배열 출력
//		for (int i = 0; i < R; i++) {
//			for (int j = 0; j < C; j++) {
//				System.out.print(field[i][j] + " ");
//			}
//			System.out.println();
//		}
//		System.out.println();
		
		answer = 0;
		for (int i = 0; i < R; i++) {
			testfield = field.clone();
			find(i,i,0,0,1);
		}
		
		System.out.println("답 : " + answer);
		
	}

	// 테스트 필드로 해줘야함 
	static int[] dx = { -1, 0, 1 };
	public static boolean find(int StartX, int x, int y, int depth, int routeN) {
		int myX = x;
		testfield[myX][y] =  (char) (routeN + '0');
		
		if (depth == C-1) {
			answer = Math.max(routeN, answer);			
			// 밑에지점부터 다시 시작
			for (int i = StartX+1; i < R; i++) {
				find(i, i,0,0,routeN+1);
			}
			testfield[x][y] = '.';
			return true;
		}
		
		for (int i = 0; i < 3; i++) {
			int nextX = myX + dx[i];
			int nextY = y + 1;
			if (nextX < 0 || nextX >= R || nextY == C || 
					testfield[nextX][nextY] != '.') continue;
			
			find(StartX, nextX, nextY, depth+1, routeN);
		}
		testfield[x][y] = '.';
		return false;
	}
}
```


두번째풀이 : 과감하게 재귀를 버리고 열단위로 체크하여서 필드를 바로바로 수정했다.
```java


```