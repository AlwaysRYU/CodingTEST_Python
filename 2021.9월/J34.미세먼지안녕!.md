# 미세먼지 안녕!
https://www.acmicpc.net/problem/17144
### 유형
시뮬레이션 / 2차원 배열 다루기 / 

* 히히 시뮬레이션에 제일 재밌다 이말이야 
* 오랜만에 한번에 통과했다!
```java
package KDS08_문자열;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.StringTokenizer;

// https://www.acmicpc.net/problem/17144
public class 문제풀이03_미세먼지안녕 {
	static int R,C,T;
	static int[][] field;
	
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		R = Integer.parseInt(st.nextToken());
		C = Integer.parseInt(st.nextToken());
		T = Integer.parseInt(st.nextToken());
		
		// 초기 필드 입력받기
		field = new int[R][C];
		for (int i = 0; i < R; i++) {
			st = new StringTokenizer(br.readLine());
			for (int j = 0; j < C; j++) {
				field[i][j] = Integer.parseInt(st.nextToken());
				
			}
		}
		
		int RC_index = 0;
		int C_index = 0;
		for (int i = 0; i < R; i++) {
			if ( field[i][0] == -1 ) {
				RC_index = i;
				C_index = i +1;
				break;
			}
		}
		
		
//		System.out.println();
//		for (int i = 0; i < R; i++) {
//			for (int j = 0; j < C; j++) {
//				System.out.print(field[i][j] + " ");
//			}
//			System.out.println();
//		}
//		System.out.println();
		
		// 시간에 따라 
		int time = 0;
		while( time < T) {
//			System.out.println("DKDK");
			
			// 1. 미세먼지가 확산된다.
			field = spread_dust(field);
			field[RC_index][0] = -1;
			field[C_index][0] = -1;
			
//			System.out.println();
//			for (int i = 0; i < R; i++) {
//				for (int j = 0; j < C; j++) {
//					System.out.print(field[i][j] + " ");
//				}
//				System.out.println();
//			}
//			System.out.println();
			
			// 2. 공기청정기가 작동한다.
//			field = air_cleaner();
			
			// 2-1. 위쪽 돌리기 
			// 나. 위쪽 반시계 돌리기
			ReverseClock( 0, RC_index);
			
//			System.out.println();
//			for (int i = 0; i < R; i++) {
//				for (int j = 0; j < C; j++) {
//					System.out.print(field[i][j] + " ");
//				}
//				System.out.println();
//			}
//			System.out.println();
//			
			// 다. 밑쪽 시계 돌리기
			Clock( 0, C_index);
//			System.out.println();
//			for (int i = 0; i < R; i++) {
//				for (int j = 0; j < C; j++) {
//					System.out.print(field[i][j] + " ");
//				}
//				System.out.println();
//			}
//			System.out.println();
//			
			time += 1;
		}
		
		// 출력: t 초후 방에 남아있는 미세먼지의 양을 모두구한다.
		int total = 0;
		for (int i = 0; i < R; i++) {
			for (int j = 0; j < C; j++) {
				if ( field[i][j] != 0 && field[i][j] != -1 ) {
					total += field[i][j];
				}
			}
		}
		System.out.println(total);
		
		
	}
	
	




	// 1. 미세먼지 확산 메소드
	static int[] dx = {-1,1, 0, 0};
	static int[] dy = { 0,0,-1, 1};
	static class JP{
		int x;
		int y;
		public JP(int x, int y) {
			this.x = x;
			this.y = y;
		}
	}
	static int[][] spread_dust(int[][] now){
		// 반납할 행렬 , 큐등 초기화 
		int[][] after = new int[R][C];
		ArrayList<JP> dustlist = new ArrayList<>();
		
		// 가. now의 미세먼지를 모두다 리스트에
		for (int i = 0; i < R; i++) {
			for (int j = 0; j < C; j++) {
				if (now[i][j] != 0 && now[i][j] != -1) {
					// 0이아니고 -1 이 아닌경우
					// 먼지리스트에 그 좌표를 넣어두고 
					dustlist.add(new JP(i,j)); 
				}
			}
		}
		
		// 나 .리스트에 있는거 퍼트리기. 결과는 after에 저장한다.
		for (int i = 0; i < dustlist.size(); i++) {
			
			int x = dustlist.get(i).x;
			int y = dustlist.get(i).y;

			int small = now[x][y] / 5;
			int count = 0;
			for (int j = 0; j < 4; j++) {
				int nx = x + dx[j];
				int ny = y + dy[j];
				if ( nx < 0 || nx >= R || ny < 0 || ny >= C 
						|| now[nx][ny] == -1 ) continue;
				// 범위 바깥이거나 공기청정기 위치면 못함
				// 여기는 퍼트릴 수 있는 경우다.
				
				// 지금위치의  1/5 를 넣어줌
				after[nx][ny] += small; /// 더하기 해줘야함
				count += 1; // 개수 업
			}
			// 4방향 다햇으면 원래위치에는 남는거
			after[x][y] += (now[x][y] - ( small * count));
			
		}
		
		
		
		return after;
	}
	
	// 2. 미세먼지 청소 메소드 반시계 돌리기
	private static void ReverseClock(int i, int rC_index) {
		
		// 1. 시작 위치는
		
		// 왼쪽
		int index = rC_index -1;
		while(true) {
			if (index == 0 ) break;
			field[index][0] = field[index-1][0];
			index -= 1;
		}
		
		// 위
		// 지금 index 값은 0이다.
		for (int j = 0; j < C-1; j++) {
			field[0][j] = field[0][j+1];
		}
		
		// 우측
		while(true) {
			if (index == rC_index ) break;
			field[index][C-1] = field[index+1][C-1];
			index += 1;
		}
		
		// 밑
		for (int j = C-1; j >= 2; j--) {
			field[rC_index][j] = field[rC_index][j-1]; 
		}
		field[rC_index][1] = 0;
		
	}
		
	
	// 3. 시계 방향으로 돌리기 
	private static void Clock(int i, int c_index) {
		
		// 좌측 - 밑으로
		// 왼쪽
		int index = c_index +1;
		while(true) {
//			System.out.println(index);
			if (index == R-1 ) break;
			field[index][0] = field[index+1][0];
			index += 1;
		}
		
		// 밑 -> 우측으로 
		// 지금 index 값은 0이다.
		for (int j = 0; j < C-1; j++) {
			field[R-1][j] = field[R-1][j+1];
		}
		
		// 우측 - 위로
		// 지금 R-1
		while(true) {
			if (index == c_index ) break;
			field[index][C-1] = field[index-1][C-1];
			index -= 1;
		}
		
		// 위 -> 왼쪽으로
		for (int j = C-1; j >= 2; j--) {
			field[c_index][j] = field[c_index][j-1]; 
		}
		field[c_index][1] = 0;
		
	}
		


}


```