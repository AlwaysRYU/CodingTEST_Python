# 행성탐험
https://www.acmicpc.net/problem/2887

* 높은 수준의 문제이다.
```java
package M09;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.StringTokenizer;

public class D03_행성터널 {
	static int N, M;
	static planet[] list;
	static class planet {
		int x;
		int y;
		int z;
		
		public planet(int x, int y, int z) {
			super();
			this.x = x;
			this.y = y;
			this.z = z;
		}
	}
	static class V {
		int cost;
		int start;
		int end;
		public V(int cost, int start, int end) {
			super();
			this.cost = cost;
			this.start = start;
			this.end = end;
		}
	}
	
	static int[] parent;
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		// N 입력받기
		StringTokenizer st = new StringTokenizer(br.readLine());
		N = Integer.parseInt(st.nextToken());
//		list = new planet[N];
		parent = new int[N+1];
		
		// X리스트, Y리스트 , Z리스트
		// 조건이 min임으로 이렇게 계산할 수 있다.
//		ArrayList<int[]> Xlist = new ArrayList<>();
//		ArrayList<int[]> Ylist = new ArrayList<>();
//		ArrayList<int[]> Zlist = new ArrayList<>();
		
		int[][] Xlist = new int[N+1][2];
		int[][] Ylist = new int[N+1][2];
		int[][] Zlist = new int[N+1][2];
		
		for (int i = 1; i < N+1; i++) {
			st = new StringTokenizer(br.readLine());
			int xx = Integer.parseInt(st.nextToken());
			int yy = Integer.parseInt(st.nextToken());
			int zz = Integer.parseInt(st.nextToken());
			Xlist[i][0] = xx;
			Xlist[i][1] = i;
			Ylist[i][0] = yy;
			Ylist[i][1] = i;
			Zlist[i][0] = zz;
			Zlist[i][1] = i;
//			Xlist.add(new int[] {xx, i});
//			Ylist.add(new int[] {yy, i});
//			Zlist.add(new int[] {zz, i});
		}
		
		Arrays.sort(Xlist, new Comparator<int[]>() {
			@Override	
			public int compare(int[] t1, int[] t2) {
				return t1[0] - t2[0];
			}
		});
		Arrays.sort(Xlist, new Comparator<int[]>() {
			@Override	
			public int compare(int[] t1, int[] t2) {
				return t1[0] - t2[0];
			}
		});
		Arrays.sort(Xlist, new Comparator<int[]>() {
			@Override	
			public int compare(int[] t1, int[] t2) {
				return t1[0] - t2[0];
			}
		});
		
//		Collections.sort(Xlist);
//		Collections.sort(Ylist);
//		Collections.sort(Zlist);
		
		// 간선리스트
		ArrayList<V> Vlist = new ArrayList<>();
		int answer = 0; // 답		
		for (int i = 0; i < N-1; i++) {
			Vlist.add( new V(Xlist.indexOf(i+1)))
		}
		
	}
	
	static int find_parent(int[] parent, int x) {
		if (parent[x] != x)
			parent[x] = find_parent(parent, parent[x]);
		return parent[x];
	}
	static void union_parent(int[] parent, int a, int b) {
		a = find_parent(parent, a);
		b = find_parent(parent, b);
		if ( a< b) parent[b] = a;
		else parent[a] = b;
	}

}

```