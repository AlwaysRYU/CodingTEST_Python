# CH6. 정렬
 
#### 데이터를 특정한 기준에 따라서 순서대로 나열하는 것.

### 특징
  * 정렬하면, 이진탐색을 가능하게 한다.


### 선택정렬

* 가장 작은것을 '선택'
#### 방법
1. 데이터 중에서 가장 작은 데이터를 선택하여, 맨 앞에 있는 데이터와 바꾼다.
2. 그다음 작은 데이터를 선택해 두번째 데이터와 바꾼다.
3. 이를 반복한다.
#### 구현
```python
a = [7,5,9,0,3,1,6,2,4,8,10,11,12]

for i in range(len(a)):
    min_index = i
    for j in range(i+1, len(a)):
        if a[min_index] > a[j]:
            min_index = j
    a[i], a[min_index] = a[min_index], a[i]
print(a)
```

### 삽입정렬

* 바로 정렬해서 넣기
#### 시간 복잡도 
* 최선의 경우 O(n)
* 일반적으로 O(n^2) 선택도 마찬가지



### 퀵정렬
* 가장 많이 사용되는 정렬 알고리즘
#### 방법
1. 기준을 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 교환 후, 리스트를 반으로 나눈다.
2. 기준 데이터를 설정하고, 그 기준보다 작은 데이터의 위치를 바꾼다. ( 기준 = pivot )
#### 시간복잡도
* 평균 - O( N log N ) 앞선 두 정렬보다 빠르다.
* 최악의 경우 - O( N^2 ) 이미 데이터가 정렬되어있는경우 등
    


### 계수 정렬
* 특정한 조건이 부합할 때만 사용할 수 있지만, 매우 빠른 정렬 알고리즘   

    예시:
        모든 데이터가 양의 정수인 상황에서, 개수가 N, 쵀댓값이 K이 일때. 계수정렬은
        O( N + K )를 보장한다.
    계수 정렬은 이처럼 매우 빠르게 동작할 뿐만아니라 원리도 간단하다.
* 조건
    데이터의 크기 범위가 제한 되어있는 정수 형태
    예시:
        0 ~ 100 이하
#### 특징
* 별도의 리스트를 선언하고 정렬에 대한 정보를 담는다.

#### 방법
1. 큰 데이터와 가장 작은 데이터의 범위가 모두 담길 수 있도록 하나의 리스트를 생성한다.
2. 리스트 안의 모든 데이터가 0이 되도록 초기화 한다.
3. 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가 시킨다.
4. 인덱스의 값은, 숫자가 나온 횟수이다. 인덱스에다가 값만큼 반복하여 출력하면 정렬이 완료된다.
#### 시간복잡도
* O( N + K ) -기수정렬 과 더불어 가장 빠르다.
#### 공간복잡도
* O(N+K)
    만약 데이터가 0 99999 두개 뿐이라면 엄청 비효율적이다.
    동일한 값을 가지는 데이터가 많을 때 적합하다.
    일반적으론 퀵을 사용합시다.
