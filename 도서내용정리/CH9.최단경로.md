
# CH9. 최단경로


 #### 특정 지점 까지 가장 빠르게 도달하는 방법을 찾는 알고리즘   

 ### 문제 예시
  > 흔히 말하는 '길찾기' 문제.   
  > 한 지점에서, 다른 특정 지점 까지의 최단 경로를 구해야 하는 경우.   
  > 모든 지점에서, 다른 모든 지점 까지의 최단경로를 구해야 하는 경우
 
 ### 푸는 방법
 >  일반적으로, 그래프를 이용해서 푼다.   
 > 다익스트라 / 플로이드 워셜 / 벨만포드 알고리즘 3가지가 있다.   
 > 다익스트라와, 플로이드 워셜 알고리즘만 알면 다 풀수 있다.   
 > 그리디 / 다이나믹 알고리즘의 한 유형이다.

***

 ## 다익스트라 최단 경로 알고리즘 
 
 ### 정의
* 여러개의 노드가 있을 때, **특정한 노드**에서 출발하여 다른 노드로 가는 **각각의 최단 경로**를 구해주는 알고리즘 이다.   

### 사용하는 조건
 * 음의 간선이 없을 때 사용가능

### 원리

 1. 출발 노드를 설정한다.
 2. 최단 거리 테이블을 초기화 한다.
 3. 방문하지 않은 노드 중에서 최단거릭 가장 짧은 노드를 선택한다.
 4. 해당노드를 거쳐 다른 노드로 가능 비용을 계산하여 최단거리 테이블을 갱신한다.
 5. 3,4를 반복한다.

### 특징 
 * 최단경로를 구하는 과정에서, 각 노드에 대한 현재까지의 최단 거리 정보를 항상 1차원리스트에 저장하며, 리스트를 계속 갱신한다.
 * 매번 현재 처리하고 있는 노드를 기준으로 간선을 확인한다.
 * 기본적으로 그리디 알고리즘이다.
 * 한 단계당 하나의 노드에 대한 최단 거리를 확실히 찾는 것으로 이해한다.

 ### 구현
  구현방법은 2가지가 있다. 쉽고 느린 방법과, 어렵고 빠른 방법.   
  어려운 방법은 눈감고 코딩할 정도로 숙달되어 있어야 한다.

    0. 방문하지 않은 노드 중에서 최단거리가 가장 짧은 노드를 선택하는데, 출발 노드에서 출발 노드로의 거리는 0으로 보기 때문에 처음에는 출발노드가 선택된다.
    1. 1번 노드 (출발노드)를 거쳐서 다른 노드로 가는 비용을 계산한다. 즉, 1번 노드에 연결된 간선을 모두 확인하는 것이다.
    2. 방문하지 않은 노드 중에서 최단거리가 가장 짧은 노드를 선택한다. 그리고 연결된 간선을 확인한다.
    3. 기존의 리스트 값과 확인하고 작은 것으로 리스트를 갱신한다.
    4. 다른 노드의 간선을비교하면서 리스트를 모두 갱신한다.

### 코드
#### 방법 1. 알고리즘을 그래도 구현하기.
* 시간복잡도 : O(V^2) (V는 노드의 개수)
* 단계마다 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 고르기 위해, 매 단계마다 리스트의 모든 원소를 확인한다.

### 방법 2. 힙 구조를 이용해서 구현하기.
* 시간복잡도 : O(ElogV) (V는 노드, E는 간선의 개수)
* 힙(Heap)자료구조를 사용한다.
* 힙은 우선순우 큐를 구현하기 위해 보통 사용한다.
```python

import sys
input = sys.stdin.readline
INF = int(1e9) # 무한을 의미한다.
n, m = map(int, input().splint()) # 노드의 개수, 간선의 개수를 입력받기
start = int(input()) # 시작 노드
graph = [[] for i in range( n + 1 )] #각 노드에 연결되어있는 노드에 대한 정보를담는 리스트
visited = [False] * (n+1) # 방문했는지 확인하는 리스트
distance = [INF] * (n+1) # 최단 거리 테이블을 모두 무한으로 초기화

# 모든 간선 정보를 입력받기.
for _ in range(m):
    a, b, c = map(int, input().split())

```

***
 ## 플로이드 워셜 알고리즘 
 
 ### 정의
* 모든 지점에서 **다른 모든 지점**까지의 최단 경로를 구해야하는 경우에 사용할 수 있는 알고리즘    

### 사용하는 조건
 * 음의 간선이 없을 때 사용가능

### 원리

 1. 출발 노드를 설정한다.
 2. 최단 거리 테이블을 초기화 한다.
 3. 방문하지 않은 노드 중에서 최단거릭 가장 짧은 노드를 선택한다.
 4. 해당노드를 거쳐 다른 노드로 가능 비용을 계산하여 최단거리 테이블을 갱신한다.
 5. 3,4를 반복한다.

### 특징 
 * 시간복잡도 O(N^3)
 * 다이나믹 프로그래밍의 특징
 * 기본적으로 그리디 알고리즘이다.
 * 한 단계당 하나의 노드에 대한 최단 거리를 확실히 찾는 것으로 이해한다.

 ### 구현
  구현방법은 2가지가 있다. 쉽고 느린 방법과, 어렵고 빠른 방법.   
  어려운 방법은 눈감고 코딩할 정도로 숙달되어 있어야 한다.

    0. 방문하지 않은 노드 중에서 최단거리가 가장 짧은 노드를 선택하는데, 출발 노드에서 출발 노드로의 거리는 0으로 보기 때문에 처음에는 출발노드가 선택된다.
    1. 1번 노드 (출발노드)를 거쳐서 다른 노드로 가는 비용을 계산한다. 즉, 1번 노드에 연결된 간선을 모두 확인하는 것이다.
    2. 방문하지 않은 노드 중에서 최단거리가 가장 짧은 노드를 선택한다. 그리고 연결된 간선을 확인한다.
    3. 기존의 리스트 값과 확인하고 작은 것으로 리스트를 갱신한다.
    4. 다른 노드의 간선을비교하면서 리스트를 모두 갱신한다.

### 코드
#### 방법 1. 알고리즘을 그래도 구현하기.
* 시간복잡도 : O(V^2) (V는 노드의 개수)
* 단계마다 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 고르기 위해, 매 단계마다 리스트의 모든 원소를 확인한다.

### 방법 2. 힙 구조를 이용해서 구현하기.
* 시간복잡도 : O(ElogV) (V는 노드, E는 간선의 개수)
* 힙(Heap)자료구조를 사용한다.
* 힙은 우선순우 큐를 구현하기 위해 보통 사용한다.
```python

