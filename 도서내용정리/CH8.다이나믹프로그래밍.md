# CH8. 다이나믹 프로그래밍

 #### 큰 문제를 작게 나누고, 같은 문제라면 한번씩만 풀어서 문제를 효율적으로 해결하는 알고리즘 기법

 * 어떤문제는 메모리공간을 약간 더 사용하면, 연산 속도를 비약적으로 증가 시킬 수 있다.   
 
 * 대표적인 방식
   + 탑 다운
   + 바텀 업
   + 메모이제이션 기법

 * 예제
    > + 피보나치 수열   
    > 1 1 2 3 5 8 13 21 34 66 89 ...   
    > 수학자들은 점화식을 이용한다.   
    > 우리는, 배열이나 리스트로 이것을 표현한다.
   
    + 다른 예제: 
        2021.6월/ 03.1로 만들기.py 

```{.python}
def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x-1) + fibo( x -2 )
``` 

  * 다이나믹 프로그래밍을 사용하는 경우
    + 큰 문제를 작은 문제로 나눌 수 있을 때
    + 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일할 때.

* ### 메모지에이션 기법 (하향식)  

    + 다이나믹 프로그래밍을 구현하는 방법.
    + 한번 구현한 결과를, 메모리공간에 메모해두고, 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법을 말한다.
    + 캐싱(Cashing) 이라고도 한다.
    + 파이썬에서는 리스트에 값을 저장해 놓는 것이다.
    + 다음은 메모지에이션 기법으로 구현한 피보나치 수열이다.
    
```{.python}
    memo = [0] * ~
    def fibomemo(x):
        if x == 1 or x == 2
            return 1
        if d[x] != 0
            return d[x]
        d[x] = fibo(x-1) + fibo(x-2)
        return d[x]
```


* ### 탑 다운 방식 (하향식)
    + 재귀함수를 이용해서 다이나믹 프로그래밍 소스코드를 작성하는 방법
    + 큰 문제를 해결하기 위해, 작은 문제를 호출하는 방법 
    
* ### 바텀 업 방식 (상향식)
    + 단순한 반복문을 이용해서 소스코드를 작성하는 경우

```{.python}

d[1]
d[2]
n = 99

for i in range(3, n + 1) :
    d[i] = d[i-1] + d[i-2]

```


* ### 문제를 푸는 방법
  + 주어진 문제가 다이나믹 프로그래밍 유형임을 파악한다.
  + 재귀 함수를 사용하여서 풀고, 메모지에이션을 적용할 수 있으면 코드를 개선한다.
  + 가능하다면, 탑다운 보다는 바텀업을 권장한다. 시스템상으로 재귀함수의 스택의 크기가 한정되어 있을 수 있기 때문이다. 실제로 5000번 이상의 피보나치를 구하려면 오류가난다.
  + 이럴 때는, sys라이브러리에 포함되어 있는 setrecursionlmit() 함수를 호출하여 재귀 제한을 완화할 수 있다는 점을 기억하자.
